// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package model

import (
	"fmt"
	"strings"
)

const (
	// LangEn is a Lang of type en.
	// English
	LangEn Lang = "en"
	// LangZhHans is a Lang of type zh-Hans.
	// Simplified Chinese
	LangZhHans Lang = "zh-Hans"
	// LangZhHant is a Lang of type zh-Hant.
	// Traditional Chinese
	LangZhHant Lang = "zh-Hant"
)

var ErrInvalidLang = fmt.Errorf("not a valid Lang, try [%s]", strings.Join(_LangNames, ", "))

var _LangNames = []string{
	string(LangEn),
	string(LangZhHans),
	string(LangZhHant),
}

// LangNames returns a list of possible string values of Lang.
func LangNames() []string {
	tmp := make([]string, len(_LangNames))
	copy(tmp, _LangNames)
	return tmp
}

// LangValues returns a list of the values for Lang
func LangValues() []Lang {
	return []Lang{
		LangEn,
		LangZhHans,
		LangZhHant,
	}
}

// String implements the Stringer interface.
func (x Lang) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Lang) IsValid() bool {
	_, err := ParseLang(string(x))
	return err == nil
}

var _LangValue = map[string]Lang{
	"en":      LangEn,
	"zh-Hans": LangZhHans,
	"zh-Hant": LangZhHant,
}

// ParseLang attempts to convert a string to a Lang.
func ParseLang(name string) (Lang, error) {
	if x, ok := _LangValue[name]; ok {
		return x, nil
	}
	return Lang(""), fmt.Errorf("%s is %w", name, ErrInvalidLang)
}

var _LangTextMap = map[Lang]string{
	LangEn:     "English",
	LangZhHans: "Simplified Chinese",
	LangZhHant: "Traditional Chinese",
}

func (x Lang) Text(upCaseHead bool) string {
	text := _LangTextMap[x]
	if upCaseHead {
		text = strings.ToUpper(text[:1]) + text[1:]
	} else {
		text = strings.ToLower(text[:1]) + text[1:]
	}
	return text
}
