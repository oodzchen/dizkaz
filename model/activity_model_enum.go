// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package model

import (
	"fmt"
	"strings"

	"github.com/nicksnyder/go-i18n/v2/i18n"
	i18nc "github.com/oodzchen/dizkaz/i18n"
)

const (
	// AcModelEmpty is a AcModel of type empty.
	// Empty
	AcModelEmpty AcModel = "empty"
	// AcModelUser is a AcModel of type user.
	// User
	AcModelUser AcModel = "user"
	// AcModelArticle is a AcModel of type article.
	// Article
	AcModelArticle AcModel = "article"
	// AcModelRole is a AcModel of type role.
	// Role
	AcModelRole AcModel = "role"
)

var ErrInvalidAcModel = fmt.Errorf("not a valid AcModel, try [%s]", strings.Join(_AcModelNames, ", "))

var _AcModelNames = []string{
	string(AcModelEmpty),
	string(AcModelUser),
	string(AcModelArticle),
	string(AcModelRole),
}

// AcModelNames returns a list of possible string values of AcModel.
func AcModelNames() []string {
	tmp := make([]string, len(_AcModelNames))
	copy(tmp, _AcModelNames)
	return tmp
}

// AcModelValues returns a list of the values for AcModel
func AcModelValues() []AcModel {
	return []AcModel{
		AcModelEmpty,
		AcModelUser,
		AcModelArticle,
		AcModelRole,
	}
}

// String implements the Stringer interface.
func (x AcModel) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x AcModel) IsValid() bool {
	_, err := ParseAcModel(string(x))
	return err == nil
}

var _AcModelValue = map[string]AcModel{
	"empty":   AcModelEmpty,
	"user":    AcModelUser,
	"article": AcModelArticle,
	"role":    AcModelRole,
}

// ParseAcModel attempts to convert a string to a AcModel.
func ParseAcModel(name string) (AcModel, error) {
	if x, ok := _AcModelValue[name]; ok {
		return x, nil
	}
	return AcModel(""), fmt.Errorf("%s is %w", name, ErrInvalidAcModel)
}

func (x AcModel) I18nID() string {
	return fmt.Sprintf("AcModel_%s", x.String())
}

var _AcModelTextMap = map[AcModel]string{
	AcModelEmpty:   "Empty",
	AcModelUser:    "User",
	AcModelArticle: "Article",
	AcModelRole:    "Role",
}

func (x AcModel) Text(upCaseHead bool, i18nCustom *i18nc.I18nCustom) string {
	text := []rune(_AcModelTextMap[x])

	if i18nCustom != nil {
		if _, ok := i18nCustom.Configs[x.I18nID()]; ok {
			text = []rune(i18nCustom.MustLocalize(x.I18nID(), "", ""))
		}
	}

	var res string
	if upCaseHead {
		res = strings.ToUpper(string(text[:1])) + string(text[1:])
	} else {
		res = strings.ToLower(string(text[:1])) + string(text[1:])
	}
	return res
}

func AcModelAddI18nConfigs(ic *i18nc.I18nCustom) {
	ic.AddLocalizeConfig(&i18n.Message{
		ID:    "AcModel_empty",
		Other: "Empty",
	})
	ic.AddLocalizeConfig(&i18n.Message{
		ID:    "AcModel_user",
		Other: "User",
	})
	ic.AddLocalizeConfig(&i18n.Message{
		ID:    "AcModel_article",
		Other: "Article",
	})
	ic.AddLocalizeConfig(&i18n.Message{
		ID:    "AcModel_role",
		Other: "Role",
	})
}
