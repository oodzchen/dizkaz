// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package model

import (
	"fmt"
	"strings"
)

const (
	// AcModelEmpty is a AcModel of type empty.
	// Empty
	AcModelEmpty AcModel = "empty"
	// AcModelUser is a AcModel of type user.
	// User
	AcModelUser AcModel = "user"
	// AcModelArticle is a AcModel of type article.
	// Article
	AcModelArticle AcModel = "article"
	// AcModelRole is a AcModel of type role.
	// Role
	AcModelRole AcModel = "role"
)

var ErrInvalidAcModel = fmt.Errorf("not a valid AcModel, try [%s]", strings.Join(_AcModelNames, ", "))

var _AcModelNames = []string{
	string(AcModelEmpty),
	string(AcModelUser),
	string(AcModelArticle),
	string(AcModelRole),
}

// AcModelNames returns a list of possible string values of AcModel.
func AcModelNames() []string {
	tmp := make([]string, len(_AcModelNames))
	copy(tmp, _AcModelNames)
	return tmp
}

// AcModelValues returns a list of the values for AcModel
func AcModelValues() []AcModel {
	return []AcModel{
		AcModelEmpty,
		AcModelUser,
		AcModelArticle,
		AcModelRole,
	}
}

// String implements the Stringer interface.
func (x AcModel) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x AcModel) IsValid() bool {
	_, err := ParseAcModel(string(x))
	return err == nil
}

var _AcModelValue = map[string]AcModel{
	"empty":   AcModelEmpty,
	"user":    AcModelUser,
	"article": AcModelArticle,
	"role":    AcModelRole,
}

// ParseAcModel attempts to convert a string to a AcModel.
func ParseAcModel(name string) (AcModel, error) {
	if x, ok := _AcModelValue[name]; ok {
		return x, nil
	}
	return AcModel(""), fmt.Errorf("%s is %w", name, ErrInvalidAcModel)
}

var _AcModelTextMap = map[AcModel]string{
	AcModelEmpty:   "Empty",
	AcModelUser:    "User",
	AcModelArticle: "Article",
	AcModelRole:    "Role",
}

func (x AcModel) Text(upCaseHead bool) string {
	text := _AcModelTextMap[x]
	if upCaseHead {
		text = strings.ToUpper(text[:1]) + text[1:]
	} else {
		text = strings.ToLower(text[:1]) + text[1:]
	}
	return text
}
