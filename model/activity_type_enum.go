// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package model

import (
	"fmt"
	"strings"
)

const (
	// AcTypeUser is a AcType of type user.
	// User
	AcTypeUser AcType = "user"
	// AcTypeManage is a AcType of type manage.
	// Management
	AcTypeManage AcType = "manage"
	// AcTypeAnonymous is a AcType of type anonymous.
	// Anonymous
	AcTypeAnonymous AcType = "anonymous"
	// AcTypeDev is a AcType of type dev.
	// Development
	AcTypeDev AcType = "dev"
)

var ErrInvalidAcType = fmt.Errorf("not a valid AcType, try [%s]", strings.Join(_AcTypeNames, ", "))

var _AcTypeNames = []string{
	string(AcTypeUser),
	string(AcTypeManage),
	string(AcTypeAnonymous),
	string(AcTypeDev),
}

// AcTypeNames returns a list of possible string values of AcType.
func AcTypeNames() []string {
	tmp := make([]string, len(_AcTypeNames))
	copy(tmp, _AcTypeNames)
	return tmp
}

// AcTypeValues returns a list of the values for AcType
func AcTypeValues() []AcType {
	return []AcType{
		AcTypeUser,
		AcTypeManage,
		AcTypeAnonymous,
		AcTypeDev,
	}
}

// String implements the Stringer interface.
func (x AcType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x AcType) IsValid() bool {
	_, err := ParseAcType(string(x))
	return err == nil
}

var _AcTypeValue = map[string]AcType{
	"user":      AcTypeUser,
	"manage":    AcTypeManage,
	"anonymous": AcTypeAnonymous,
	"dev":       AcTypeDev,
}

// ParseAcType attempts to convert a string to a AcType.
func ParseAcType(name string) (AcType, error) {
	if x, ok := _AcTypeValue[name]; ok {
		return x, nil
	}
	return AcType(""), fmt.Errorf("%s is %w", name, ErrInvalidAcType)
}

var _AcTypeTextMap = map[AcType]string{
	AcTypeUser:      "User",
	AcTypeManage:    "Management",
	AcTypeAnonymous: "Anonymous",
	AcTypeDev:       "Development",
}

func (x AcType) Text(upCaseHead bool) string {
	text := _AcTypeTextMap[x]
	if upCaseHead {
		text = strings.ToUpper(text[:1]) + text[1:]
	} else {
		text = strings.ToLower(text[:1]) + text[1:]
	}
	return text
}
