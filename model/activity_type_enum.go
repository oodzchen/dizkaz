// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package model

import (
	"fmt"
	"strings"

	"github.com/nicksnyder/go-i18n/v2/i18n"
	i18nc "github.com/oodzchen/dproject/i18n"
)

const (
	// AcTypeUser is a AcType of type user.
	// User
	AcTypeUser AcType = "user"
	// AcTypeManage is a AcType of type manage.
	// Management
	AcTypeManage AcType = "manage"
	// AcTypeAnonymous is a AcType of type anonymous.
	// Anonymous
	AcTypeAnonymous AcType = "anonymous"
	// AcTypeDev is a AcType of type dev.
	// Development
	AcTypeDev AcType = "dev"
)

var ErrInvalidAcType = fmt.Errorf("not a valid AcType, try [%s]", strings.Join(_AcTypeNames, ", "))

var _AcTypeNames = []string{
	string(AcTypeUser),
	string(AcTypeManage),
	string(AcTypeAnonymous),
	string(AcTypeDev),
}

// AcTypeNames returns a list of possible string values of AcType.
func AcTypeNames() []string {
	tmp := make([]string, len(_AcTypeNames))
	copy(tmp, _AcTypeNames)
	return tmp
}

// AcTypeValues returns a list of the values for AcType
func AcTypeValues() []AcType {
	return []AcType{
		AcTypeUser,
		AcTypeManage,
		AcTypeAnonymous,
		AcTypeDev,
	}
}

// String implements the Stringer interface.
func (x AcType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x AcType) IsValid() bool {
	_, err := ParseAcType(string(x))
	return err == nil
}

var _AcTypeValue = map[string]AcType{
	"user":      AcTypeUser,
	"manage":    AcTypeManage,
	"anonymous": AcTypeAnonymous,
	"dev":       AcTypeDev,
}

// ParseAcType attempts to convert a string to a AcType.
func ParseAcType(name string) (AcType, error) {
	if x, ok := _AcTypeValue[name]; ok {
		return x, nil
	}
	return AcType(""), fmt.Errorf("%s is %w", name, ErrInvalidAcType)
}

func (x AcType) I18nID() string {
	return fmt.Sprintf("AcType_%s", x.String())
}

var _AcTypeTextMap = map[AcType]string{
	AcTypeUser:      "User",
	AcTypeManage:    "Management",
	AcTypeAnonymous: "Anonymous",
	AcTypeDev:       "Development",
}

func (x AcType) Text(upCaseHead bool, i18nCustom *i18nc.I18nCustom) string {
	text := []rune(_AcTypeTextMap[x])

	if i18nCustom != nil {
		if _, ok := i18nCustom.Configs[x.I18nID()]; ok {
			text = []rune(i18nCustom.MustLocalize(x.I18nID(), "", ""))
		}
	}

	var res string
	if upCaseHead {
		res = strings.ToUpper(string(text[:1])) + string(text[1:])
	} else {
		res = strings.ToLower(string(text[:1])) + string(text[1:])
	}
	return res
}

func AcTypeAddI18nConfigs(ic *i18nc.I18nCustom) {
	ic.AddLocalizeConfig(&i18n.Message{
		ID:    "AcType_user",
		Other: "User",
	})
	ic.AddLocalizeConfig(&i18n.Message{
		ID:    "AcType_manage",
		Other: "Management",
	})
	ic.AddLocalizeConfig(&i18n.Message{
		ID:    "AcType_anonymous",
		Other: "Anonymous",
	})
	ic.AddLocalizeConfig(&i18n.Message{
		ID:    "AcType_dev",
		Other: "Development",
	})
}
